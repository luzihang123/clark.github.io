<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[把布隆过滤器用起来]]></title>
    <url>%2F%E6%8A%8A%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%94%A8%E8%B5%B7%E6%9D%A5.html</url>
    <content type="text"><![CDATA[把布隆过滤器用起来本文偏应用和代码实践，理论请参考本文末尾参考文章 简介一句话简介：过滤器，判断这个元素在与不在，不在则100%不在；在则去查询，确认在不在。 详细简介：BloomFilter，中文名称叫做布隆过滤器，是1970年由 Bloom 提出的，它可以被用来检测一个元素是否在一个集合中，它的空间利用效率很高，使用它可以大大节省存储空间。BloomFilter 使用位数组表示一个待检测集合，并可以快速地通过概率算法判断一个元素是否存在于这个集合中，所以利用这个算法我们可以实现去重效果。 它的优点是空间效率和查询时间都远远超过一般算法，缺点是有一定的误识别率和删除困难。 场景1、大量爬虫数据去重 2、保护数据安全：广告精确投放 ：广告主通过设备id，计算hash算法，在数据包（数据提供方）中去查找，如果在存在，则证明该设备id属于目标人群，进行投放广告，同时保证设备id不泄露。数据提供方和广告主都没有暴露自己拥有的设备id。间接用户画像且不违数据安全法。详见：https://zhuanlan.zhihu.com/p/37847480 3、比特币网络转账确认 SPV节点:SPV是“Simplified Payment Verification”（简单支付验证）的缩写。中本聪论文简要地提及了这一概念，指出：不运行完全节点也可验证支付，用户只需要保存所有的block header就可以了。用户虽然不能自己验证交易，但如果能够从区块链的某处找到相符的交易，他就可以知道网络已经认可了这笔交易，而且得到了网络的多少个确认。 先去访问布隆过滤器，去判断交易记录是否在某个block(区块)里存在。从海量数据(十亿个区块，每个区块1-2M的交易记录，)，快速得到结果。https://www.youtube.com/watch?v=uC6Q5m0SSQ0 4、分布式系统（Map-Reduce）把大任务切分成块，分配和验证一个子任务是否在一个子系统上。 必要性：省空间，提升效率 我们首先来回顾一下 ScrapyRedis 的去重机制，它将 Request 的指纹存储到了 Redis 集合中，每个指纹的长度为 40，例如 27adcc2e8979cdee0c9cecbbe8bf8ff51edefb61 就是一个指纹，它的每一位都是 16 进制数。 让我们来计算一下用这种方式耗费的存储空间，每个 16 进制数占用 4b，1 个指纹用 40 个 16 进制数表示，占用空间为 20B，所以 1 万个指纹即占用空间 200KB，1 亿个指纹即占用 2G，所以当我们的爬取数量达到上亿级别时，Redis 的占用的内存就会变得很高，而且这仅仅是指纹的存储，另外 Redis 还存储了爬取队列，内存占用会进一步提高，更别说有多个 Scrapy 项目同时爬取的情况了。所以当爬取达到亿级别规模时 ScrapyRedis 提供的集合去重已经不能满足我们的要求，所以在这里我们需要使用一个更加节省内存的去重算法，它叫做 BloomFilter。 (内存版)Python实现的内存版布隆过滤器pybloomhttps://github.com/jaybaird/python-bloomfilter安装:1pip install pybloom 该模块包含两个类实现布隆过滤器功能。BloomFilter 是定容。ScalableBloomFilter 可以自动扩容 使用:1234567891011121314151617&gt;&gt;&gt; from pybloom import BloomFilter&gt;&gt;&gt; f = BloomFilter(capacity=1000, error_rate=0.001) # capacity是容量, error_rate 是能容忍的误报率&gt;&gt;&gt; f.add('Traim304') # 当不存在该元素,返回FalseFalse&gt;&gt;&gt; f.add('Traim304') # 若存在,返回 TrueTrue&gt;&gt;&gt; 'Traim304' in f # 值得注意的是若返回 True。该元素可能存在, 也可能不存在。过滤器能容许存在一定的错误True&gt;&gt;&gt; 'Jacob' in f # 但是 False。则必定不存在False&gt;&gt;&gt; len(f) # 当前存在的元素1&gt;&gt;&gt; f = BloomFilter(capacity=1000, error_rate=0.001) &gt;&gt;&gt; from pybloom import ScalableBloomFilter&gt;&gt;&gt; sbf = ScalableBloomFilter(mode=ScalableBloomFilter.SMALL_SET_GROWTH)&gt;&gt;&gt; # sbf.add() 与 BloomFilter 同 超过误报率时抛出异常123456789101112131415161718&gt;&gt;&gt; f = BloomFilter(capacity=1000, error_rate=0.0000001)&gt;&gt;&gt; for a in range(1000):... _ = f.add(a)...&gt;&gt;&gt; len(a)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: object of type 'int' has no len()&gt;&gt;&gt; len(f)1000&gt;&gt;&gt; f.add(1000)False&gt;&gt;&gt; f.add(1001) # 当误报率超过 error_rate 会报错Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "/usr/local/lib/python2.7/site-packages/pybloom/pybloom.py", line 182, in add raise IndexError("BloomFilter is at capacity")IndexError: BloomFilter is at capacity (持久化)手动实现的redis版布隆过滤器大数据量，多用Redis持久化版本的布隆过滤器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102# 布隆过滤器 redis版本实现import hashlibimport redisimport six# 1. 多个hash函数的实现和求值# 2. hash表实现和实现对应的映射和判断class MultipleHash(object): '''根据提供的原始数据，和预定义的多个salt，生成多个hash函数值''' def __init__(self, salts, hash_func_name="md5"): self.hash_func = getattr(hashlib, hash_func_name) if len(salts) &lt; 3: raise Exception("请至少提供3个salt") self.salts = salts def get_hash_values(self, data): '''根据提供的原始数据, 返回多个hash函数值''' hash_values = [] for i in self.salts: hash_obj = self.hash_func() hash_obj.update(self._safe_data(data)) hash_obj.update(self._safe_data(i)) ret = hash_obj.hexdigest() hash_values.append(int(ret, 16)) return hash_values def _safe_data(self, data): ''' python2 str === python3 bytes python2 uniocde === python3 str :param data: 给定的原始数据 :return: 二进制类型的字符串数据 ''' if six.PY3: if isinstance(data, bytes): return data elif isinstance(data, str): return data.encode() else: raise Exception("请提供一个字符串") # 建议使用英文来描述 else: if isinstance(data, str): return data elif isinstance(data, unicode): return data.encode() else: raise Exception("请提供一个字符串") # 建议使用英文来描述class BloomFilter(object): '''''' def __init__(self, salts, redis_host="localhost", redis_port=6379, redis_db=0, redis_key="bloomfilter"): self.redis_host = redis_host self.redis_port = redis_port self.redis_db = redis_db self.redis_key = redis_key self.client = self._get_redis_client() self.multiple_hash = MultipleHash(salts) def _get_redis_client(self): '''返回一个redis连接对象''' pool = redis.ConnectionPool(host=self.redis_host, port=self.redis_port, db=self.redis_db) client = redis.StrictRedis(connection_pool=pool) return client def save(self, data): '''''' hash_values = self.multiple_hash.get_hash_values(data) for hash_value in hash_values: offset = self._get_offset(hash_value) self.client.setbit(self.redis_key, offset, 1) return True def is_exists(self, data): hash_values = self.multiple_hash.get_hash_values(data) for hash_value in hash_values: offset = self._get_offset(hash_value) v = self.client.getbit(self.redis_key, offset) if v == 0: return False return True def _get_offset(self, hash_value): # 512M长度哈希表 # 2**8 = 256 # 2**20 = 1024 * 1024 # (2**8 * 2**20 * 2*3) 代表hash表的长度 如果同一项目中不能更改 return hash_value % (2**8 * 2**20 * 2*3)if __name__ == '__main__': data = ["asdfasdf", "123", "123", "456","asf", "asf"] bm = BloomFilter(salts=["1","2","3", "4"],redis_host="172.17.0.2") for d in data: if not bm.is_exists(d): bm.save(d) print("映射数据成功： ", d) else: print("发现重复数据：", d) 应用在scrapy-redis中代码已经打包成了一个 Python 包并发布到了 PyPi，链接为：https://pypi.python.org/pypi/scrapy-redis-bloomfilter，因此我们以后如果想使用 ScrapyRedisBloomFilter 直接使用就好了，不需要再自己实现一遍。 我们可以直接使用Pip来安装，命令如下：1pip3 install scrapy-redis-bloomfilter 使用的方法和 ScrapyRedis 基本相似，在这里说明几个关键配置：123456# 去重类，要使用BloomFilter请替换DUPEFILTER_CLASSDUPEFILTER_CLASS = "scrapy_redis_bloomfilter.dupefilter.RFPDupeFilter"# 哈希函数的个数，默认为6，可以自行修改BLOOMFILTER_HASH_NUMBER = 6# BloomFilter的bit参数，默认30，占用128MB空间，去重量级1亿BLOOMFILTER_BIT = 30 DUPEFILTER_CLASS 是去重类，如果要使用 BloomFilter需要将 DUPEFILTER_CLASS 修改为该包的去重类。 BLOOMFILTER_HASH_NUMBER 是 BloomFilter 使用的哈希函数的个数，默认为 6，可以根据去重量级自行修改。 BLOOMFILTER_BIT 即前文所介绍的 BloomFilter 类的 bit 参数，它决定了位数组的位数，如果 BLOOMFILTER_BIT 为 30，那么位数组位数为 2 的 30次方，将占用 Redis 128MB 的存储空间，去重量级在 1 亿左右，即对应爬取量级 1 亿左右。如果爬取量级在 10亿、20 亿甚至 100 亿，请务必将此参数对应调高。 测试12345678910111213141516171819Spider 文件:from scrapy import Request, Spiderclass TestSpider(Spider): name = 'test' base_url = 'https://www.baidu.com/s?wd=' def start_requests(self): for i in range(10): url = self.base_url + str(i) yield Request(url, callback=self.parse) # Here contains 10 duplicated Requests for i in range(100): url = self.base_url + str(i) yield Request(url, callback=self.parse) def parse(self, response): self.logger.debug('Response of ' + response.url) 在 start_requests() 方法中首先循环 10 次，构造参数为 0-9 的 URL，然后重新循环了 100 次，构造了参数为 0-99 的 URL，那么这里就会包含 10 个重复的 Request，我们运行项目测试一下：1scrapy crawl test 可以看到最后的输出结果如下：1234567891011121314151617&#123;'bloomfilter/filtered': 10, 'downloader/request_bytes': 34021, 'downloader/request_count': 100, 'downloader/request_method_count/GET': 100, 'downloader/response_bytes': 72943, 'downloader/response_count': 100, 'downloader/response_status_count/200': 100, 'finish_reason': 'finished', 'finish_time': datetime.datetime(2017, 8, 11, 9, 34, 30, 419597), 'log_count/DEBUG': 202, 'log_count/INFO': 7, 'memusage/max': 54153216, 'memusage/startup': 54153216, 'response_received_count': 100, 'scheduler/dequeued/redis': 100, 'scheduler/enqueued/redis': 100, 'start_time': datetime.datetime(2017, 8, 11, 9, 34, 26, 495018)&#125; 可以看到最后统计的第一行的结果：1'bloomfilter/filtered': 10, 这就是 BloomFilter 过滤后的统计结果，可以看到它的过滤个数为 10 个，也就是它成功将重复的 10 个 Reqeust 识别出来了，测试通过。 原理本文偏应用，难以描述的原理，最后说。一个很长的二进制向量和一个映射函数。 参考资料1、https://zhuanlan.zhihu.com/p/378474802、https://www.youtube.com/watch?v=uC6Q5m0SSQ03、《python3网络爬虫开发实战》崔庆才4、https://www.jianshu.com/p/f57187e2b5b9]]></content>
  </entry>
  <entry>
    <title><![CDATA[02Python中一切皆对象——Python高级编程和异步IO并发编程]]></title>
    <url>%2F02Python%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94Python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5IO%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html</url>
    <content type="text"><![CDATA[02Python中一切皆对象——Python高级编程和异步IO并发编程2.1 Python中一切皆是对象讲解动态语言和静态语言的区别Python的面向对象更彻底函数和类也是对象，属于Python的一等公民1、赋值给一个变量2、可以添加到集合对象中3、可以作为参数传递给函数4、可以当做函数的返回值2.2 type、object和class的关系2.3 Python中的常见内置类型2.4 本章小结]]></content>
  </entry>
  <entry>
    <title><![CDATA[01课程介绍——Python高级编程和异步IO并发编程]]></title>
    <url>%2F01%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D%E2%80%94%E2%80%94Python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5IO%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html</url>
    <content type="text"><![CDATA[01课程介绍——Python高级编程和异步IO并发编程为什么需要进阶Python高级工程师会面试什么我们只需要知道当前的Python知识就够了吗？语言本身的进阶知识优先于框架，大公司更注重语言本身的功底 如何进阶和大神一起阅读优秀源码、懂原理面试、多做项目 你是否遇到看不懂优秀库和框架的源码不知道如何才能进一步优化自己的代码asyncio、tornado 等异步框架背后的原理Python代码灵活背后的设计原理对生成器稀里糊涂很多Python抛出的异常看不懂 课程概述目标：系统全面学习Python高级知识和并发编程方法：功能-&gt;原理-&gt;应用案例技术：面向对象、魔法方法、元类、生成器、多线程-&gt;协程 章节安排01 课程介绍02 Python中一切皆对象03 魔法方法04 深入类和对象05 自定义序列类06 深入Python的set和dict07 对象引用、可变性和垃圾回收08 元类编程09 迭代器和生成器10 Python socket编程11 多线程、多进程和线程池编程12、协程和异步IO13、asyncio并发编程14、课程总结课程安排一切皆对象魔法方法详解Python序列协议深入dict和set迭代器和生成器详解socket编程详解对象引用和可变性、垃圾回收元类编程多线程（池）、多进程（池）异步io和协程asyncio并发编程课程安排-面向对象鸭子类型抽象基类MRO属性查找算法和super函数静态方法、类方法、实例方法数据封装和私有属性对象的自省机制上下文管理器contextlib实现上下文管理器mixin继承模式的应用课程安排-元类property动态属性getattr、getattribute的区别属性描述符new和init元类实现orm课程安排-多线程GIL和多线程线程通信-共享变量、Queue线程同步-Lock、RLock、Condition、Semaphores线程池和源码分析-ThreadPoolExecutor多进程-multiprocessing进程间通信课程安排-异步IOIO多路复用-select、poll、epollselect+回调+事件循环模式生成器进阶-send、close、throw和yield fromasync和await课程安排-asyncioFuture和Taskaiohttp实现高并发抓取urlasyncio 背后的selector协程同步和通信ThreadPoolExecutor + asyncio]]></content>
  </entry>
  <entry>
    <title><![CDATA[scrapy-spalsh使用UA和IP代理]]></title>
    <url>%2Fscrapy-spalsh%E4%BD%BF%E7%94%A8UA%E5%92%8CIP%E4%BB%A3%E7%90%86.html</url>
    <content type="text"><![CDATA[scrapy-spalsh使用UA和IP代理核心设置UA，优先在lua脚本中使用splash:set_user_agent(“{ua}”) 设置ip代理，使用SplashRequest的proxy 代码1pip install fake-useragent 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: utf-8 -*-import scrapyfrom scrapy import Spiderfrom urllib.parse import quotefrom scrapy_splash import SplashRequestfrom risk_control_info.utils import get_proxy_ipfrom fake_useragent import UserAgentua = UserAgent()script = """function main(splash, args) splash.images_enabled = false splash:set_user_agent("&#123;ua&#125;") assert(splash:go(args.url)) assert(splash:wait(args.wait)) return splash:html()end""".format(ua=ua.chrome)class AppQimaiHotSearchSpider(scrapy.Spider): name = 'app_qimai_hot_search' allowed_domains = ['qimai.cn'] user_agent = ua.chrome custom_settings = &#123; 'DOWNLOADER_MIDDLEWARES': &#123; 'scrapy_splash.SplashCookiesMiddleware': 723, 'scrapy_splash.SplashMiddleware': 725, 'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware': 810, &#125;, 'SPIDER_MIDDLEWARES': &#123; 'scrapy_splash.SplashDeduplicateArgsMiddleware': 100, &#125;, &#125; def start_requests(self): url = "http://httpbin.org/get" yield SplashRequest(url=url, callback=self.parse, endpoint='execute', args=&#123; 'lua_source': script, 'proxy': "http://" + get_proxy_ip(url), 'wait': 3&#125;) def parse(self, response): print(response.body.decode()) 结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[00 机器学习概述、特征工程、机器学习算法]]></title>
    <url>%2F00%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[00 机器学习概述、特征工程、机器学习算法引入：”人工智能之父“ 艾伦图灵：图灵测试 马文·李·闵斯基（英语：Marvin Lee Minsky，1927年8月9日－2016年1月24日），科学家专长于认知科学与人工智能领域，麻省理工学院人工智能实验室的创始人之一，著有几部人工智能和哲学方面的作品。1969年，因为在人工智能领域的贡献，获得图灵奖。 关系 新闻一“小”一“同”南方都市报的“小南”，广州日报的“阿同”机器人 技术方面的话，主要是计算机视觉，自然语言处理，数据挖掘。 计算机视觉就包括图像识别，视频识别，具体应用有人脸识别，步态识别，无人驾驶汽车等等。 自然语言处理包括机器翻译，语音识别，文本挖掘等等，像siri，谷歌翻译里面都有很多的自然语言处理技术。 数据挖掘主要是各种推荐和预测，包括电子商务的商品推荐，计算广告，社交网络分析（微博好友推荐等），预测一些趋势，比如股市的走向，天气的变化等。 无人驾驶百度：阿波罗 医疗 医疗CT 量化交易图片艺术化 GAN神经网络：视觉相关处理 Ai智能手机 智能推荐 开发框架pytorch TensorFlow： scikit-learn： 推荐书籍和知识背景 机器学习概述什么是 机器学习机器学习是从数据中自动分析获得规律（模型），并利用规律对未知数据进行预测 案例：分辨啤酒还是红酒 搜集数据： 准备数据 为什么 需要机器学习怎么用 机器学习（应用场景）数据来源与类型数据的特征工程机器学习基础]]></content>
  </entry>
</search>
